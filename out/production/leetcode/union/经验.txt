 * 【并查集】需要用到树结构，这个树结构通常是通过数组或哈希表实现的
 * 就此题而言：
 *              先扫描所有的等式，将等式两边的顶点进行合并(实际上就将两个集合联通了起来)
 *              然后扫描所有不等式，如果等式两边在同一个连通分量内，则出现矛盾，返回false；如果扫描结束没有矛盾，则返回true
 *
 * 或许你明明知道【并查集】的思想，但实现时却无从下手，接着往下看这几个[关键点]：
 *              1.并查集数组下标代表该节点本身，值代表其指向的父节点
 *              2.并查集的初始化：parent[i] = i ，父亲就是本身，各自为一个集合(也就是说每个节点都是根节点，下标等于值 是根节点的特征)
 *              3.findRoot()方法，获得根节点：从此时的node下标开始，不断取parent[node]直到 下标等于值
 *              4.union()方法，合并两个连通分量：每个等式都对应一次连通操作；如何联通呢?让一个集合的根节点，成为另一个集合根节点的子节点(☆★☆)
 *
 * 并查集的优化：
 *              如果一个路径较长的话，会影响性能 —— 长路径毫无意义，一个集合(连通分量)的树形状没有实际意义，并查集的性质只有【连通性】而无关路径
 *              在不断的扫描中，并查集一直在动态变化；其实在这个过程中，树的形状也可以同时动态变化
 *              【并查集】的优化有两种：
 *                              1.路径压缩(隔代压缩和完全压缩)：动态减小树的高度，将长路径转化掉
 *                              2.按秩合并：根据树的高度进行合并(union)，即将高度低的树接到高度高的树上，防止高度的增长，根节点和根节点进行链接合并